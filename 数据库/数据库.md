* 数据库的三范式
    * 第一范式是**属性不可分**；
    * 第二范式是在第一范式的基础上，要求实体的**属性完全依赖于主关键字，没有部分依赖**；
    * 第三范式是在第二范式的基础上，所有**属性都和主键有直接关系，没有传递依赖**。

多对多，两张表，关系表，两个外键
一对多，两张表，多的表加外键

     
***

#### MySql数据类型
* 数值型
    * INT (int)
    * TINYINT (tinyInt)
    * SMALLINT (smallInt)
    * MEDIUMINT (mediumInt)
    * BIGINT (bigInt)
    ![数值型](http://ke.dajiangtai.com/content/411/1.png)

* 浮点型
    * FLOAT (float)
    * DOUBLE (double)
    ![浮点型](http://ke.dajiangtai.com/content/411/2.png)

* 时间和日期类型
    * DATA (data)
    * TIME (time)
    * YEAR (year)
    * DATATIME (dataTime)
    * TIMESTAMP (timeStamp)
    ![时间和日期类型](http://ke.dajiangtai.com/content/411/2.png)

* 字符串类型
    * CHAR (char)
    * BINARY (binAry)
    * VARCHAR (varChar)
    * BLOB (blob)
    * TEXT (text)
    * SET (set)
    * ENUM (enum) 
    ![字符串类型](http://ke.dajiangtai.com/content/411/4.png)
        >CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。

        >BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

        >有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。
        
        >SET是集合类型不同于ENUM类型，它是一个排列组合。假如有abc，它可以选择a或b或c，也有选择是ab,ac,bc，也可以选择abc。

        >ENUM是枚举类型
***

*** 




### Redis

#### redis的五种数据结构原理分析
* <https://blog.csdn.net/xpsallwell/article/details/84030285>
* 五种数据结构
    * 字符串(String)
    * 列表(List)
    * 哈希(Hash)
    * 集合(Set)
    * 有序集合(zSet)

* 五种类型的应用场景
    > String，**redis对于KV的操作效率很高**，可以直接用作**计数器。例如，统计在线人数等等**，另外string类型是二进制**存储安全的**，所以也可以使用它来**存储图片，甚至是视频**等。
    > hash，存放键值对，一般可以用来**存某个对象的基本属性信息**，例如，**用户信息，商品信息**等，另外，由于hash的大小在小于配置的大小的时候使用的是ziplist结构，比较**节约内存**，所以针对大量的数据存储可以考虑使用hash来分段存储来达到压缩数据量，节约内存的目的，例如，对于大批量的商品对应的图片地址名称。比如：商品编码固定是10位，可以选取前7位做为hash的key,后三位作为field，图片地址作为value。这样每个hash表都不超过999个，只要把redis.conf中的hash-max-ziplist-entries改为1024，即可。
    > list，列表类型，可以用于**实现消息队列**，也可以使用它提供的range命令，做**分页查询功能**。
    > set，集合，整数的有序列表可以直接使用set。可以**用作某些去重功能，例如用户名不能重复**等，另外，还可以**对集合进行交集，并集操作，来查找某些元素的共同点**
    > zset，有序集合，可以使用**范围查找，排行榜功能**或者topN功能。

* Redis一般的应用场景
    * 缓存会话（单点登录）
    * 分布式锁，比如：使用setnx
    * 各种排行榜或计数器
    * 商品列表或用户基础数据列表等
    * 使用list作为消息对列
    * 秒杀，库存扣减等
***

## 数据库三范式
**某些情况下，会根据业务需求拿冗余换效率**<br>
没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，提高读性能，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于DML的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。
### 第一范式
**任何一张表都有主键，且每一个字段都不可再分（原子性）**

### 第二范式
**第一范式基础上，所有非主键完全依赖主键，不能产生部分依赖**（联合主键，一些字段依赖于其中一个组成主键的字段， 另外一些字段依赖与另外一个组成主键的字段）**多对多，三张表，关系表两个外键**

## 第三范式
**第二范式基础上，所有非主键字段直接依赖于主键，不存在传递依赖**（一个学生ID（主键）对应一个班级编号，一个班级编号对应一个班级名称< 学生ID->班级编号->班级名称 >） ，**一对多，两种表， 多的表加外键**

***

## MySQL数据类型
### 整数
* tinyint(8)
* smallint(16)
* mediumint(24)
* int(32)
* bigint(64)
* unsigned 不允许负值
### 实数
* float
* double
* decimal 需要额外的空间和计算开销，尽量只在对小数精确计算时使用
* 存储量较大时，可以考虑使用小数乘以相应的倍数

### 字符串类型
* varchar: 可变字符串，更节省空间，varchar需要额外的空间存储其大小，小于255时使用一个字节，大于则使用2个字节，行是可变的，存储可能更费空间（分裂）
	* 适用场景：字符串最大长度比平均长度大很多，更新很少。
	* InnoDB会把长的varchar存储为blob
* char： 定长字符串，根据定义的长度分配足够空间
	* 适用场景：存储很短的字符串， 或者所有值都接近于同一个长度，比如md5值，而且不会产生碎片， 且不需要空间来存储长度（存储一个字节时）
	
* binary: 
* varbinary: 

### BLOB和TEXT类型
* blob: 二进制,没有排序规则
	* tinyblob
	* smallblob
	* mediumblob
	* blob
	* longblob
	
* text: 字符，有字符集和排序规则
	* tinytext
	* smalltext
	* mediumtext
	* text
	* longtext
	
* 会把blob和text当做一个对象来处理， 当其值过大时，会使用外部存储区域来存储，因此需要1~4个字节来存储指针

### 枚举类型
* 不重复的字符串存储成一个预定义的集合，会将其存储为一个整数， 然后在.frm文件中存储关系对应表，所以应该避免存储整型，而且是按照对应的整型排序的，并非按照字符串规则排序
* 添加和删除必须使用alter table, 所以对于会变化的字符串，使用枚举并不好
* 开销小，因为内部位整型
 
 
### 时间和日期
MySQL能存储的最小时间粒度为秒， 但也是可以使用微妙来进行计算的

* datetime: 1001年到9999年，精度为秒，封装为整数，与时区无关
* timestamp: 从格林尼治时间以来的秒数（和unix时间戳一致），依赖于时区，默认位not null
* 尽量使用timestamp, 比datatime空间效率更高
* 如果需要更高精度，则可以使用bigint类型来存储微秒级别的时间戳，或者是double

### 位数据类型
技术上来说都是字符串类型
* bit
* set: 保存很多true/false,改变的代价很高，也无法在set列上通过索引查找
* 


















































