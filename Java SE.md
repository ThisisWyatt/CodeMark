## 1. 基础

***

#### JDK和JRE的区别

* JDK:Java开发工具包，提供了Java的**开发环境**和**运行环境**
* JRE:Java运行环境，提供Java的**运行环境**
* **JDK包含了JRE,还包含了java源码的编译器javac，以及很多java程序调试分析的工具**，如果只需要运行程序，JRE即可，如果还需要写程序则需要JDK 

***

#### Java8新特性

* Date Time API :加强对日期和时间的处理
* Optional类：用来处理空指针的问题
* Lambda表达式
* 优化HashMap,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)

***

#### Java的多态

* 多态：一种事物的多种存在形态，比如说男人和女人都是人，人可以分为男人和女人
* 好处：消除了类之间的**耦合关系**，大大提高了程序的**简洁性**和**可拓展性**
* 重写Overriding和重载Overloading
    * 重载：以类统一的方式处理不同数据的一种手段，实质就是**多个具有不同参数个数或者类型的同名函数，且返回类型可随意。**（*动态绑定*）
    * 重写：父类与子类之间的多态性，**实质就是子类对父类的函数进行重写定义**。子类的访问权限不能小于父类的访问权限。（否则调用的时候可能无法调用）（*静态绑定*）
        * 重写方法**参数列表、返回类型**必须与被重写的方法相同。
* 子类对象的多态性
    * 是**使用父类的引用，指向子类的对象**，然后虚拟方法调用子类重写父类的方法

***

#### 数据类型 自动拆装箱

* 8种，**int long short char float double byte boolean**
* **自动装箱是Java编译器在基本数据类型和对于对象包装类型中做的一个转化**。比如int类型转化为Integer,double类型转为Double等，反之及时自动拆箱。

***

#### Java中IO流分为几种

* 按照功能：**输入流**、**输出流**
* 按照类型:
    * **字节流**：按**8位传输以字节为单位**输出输出数据
    * **字符流**：按照**16位传输以字符为单位**输出输入数据

***

#### 值传递和引用传递

* 值传递对于基本类型而言的，传递的是该变量的一个副本，改变副本不影响原变量
* 引用传递对于对象类型而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象操作会改变原对象。
* 一个对象被当做参数传递给一个方法后，此方法可改变它的属性，并返回变化后的结果，那么这里是什么传递？
    * 值传递。**Java没有引用传递**，方法的参数的值是对象引用（传入的变量）的一个副本，但指向同一个对象，所以在方法中改变对象也会改变原变量的值，因为他的引用的对象改变了。

***

#### &和&&的区别

* &：按位于，**两边都要判断**

* &&：短路与，**左边的为true才会判断右边**

* 经常使用短路与，比如用户登陆时判定用户名不是null且不是空字符串时就只能用&&
    ````java
    username!=null&&username.equals("")
    ````

***

#### String、StringBuffer和StringBuilder

* 都是可以储存和操作字符串
* **String是final类型**，每次声明的都是不可变更的对象，然后将指针指向新的String对象
* StringBuffer，StringBuilder是可变字符串，在原有对象上进行操作
* **StringBuffer是线程安全的，StringBuilder不是线程安全的**，但性能更高

***

* Object若不重写hashCode()的话，hashCode()如何计算出来的？
    * Object的hashCode()方法是一个本地方法，**该方法是直接返回对象的内存地址**

***

#### equals和hashcode

* 如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode（）方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。
> 两个对象equals相等，则它们的hashcode必须相等，反之则不一定。<br>
>两个对象=相等，则其hashcode一定相等，反之亦然。<br>
>两个对象==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的<br>
>两个对象==相等，则其hashcode一定相等，反之不一定成立。<br>

***

#### ==和equals的区别

* ==
    * **基本类型：比较值是否相同**
    * **引用类型：比较的引用是否相同**
* **equals默认情况下是引用比较**，只是**很多类重载了equals()方法 (也可自定义)** ，**比如String、Integer等将它变为值比较**

***

#### final和static

* final
    * final可以修饰属性，**方法，类，局部变量**（静态变量、实例变量和局部变量）；
    * final修饰的方法**不能被子类重写**，但**可以被继承**；
    * final修饰的类**不能被继承**，没有子类，**final类中的方法默认是final的**
    * final**不能**用于修饰构造方法；
    * 对于基本类型数据，**final会将值变为一个常数（创建后不能被修改）**
* staic
    * static表示“全局”或者“静态”的意思，可以用来修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类），static**不可以修饰局部变量**
    * static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变，并且每个对象都只有一个值，主要强调它们只有一个。
    * static修饰的属性、方法、代码段跟该类的**具体对象无关**，不创建对象也能调用static修饰的属性、方法等，
    * static和“this、super”势不两立，因为this、super正好跟具体对象有关。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。
    * 用public修饰的static属性和方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。

* static final(等价于final staic)
    * static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用

***

#### 静态代码块与普通代码块的区别

* ````java
    public class HelloB extends HelloA 
    {
        public HelloB(){
        }

        {
            System.out.println("I’m B class");
        }

        static{
            System.out.println("static B");
        }

        public static void main(String[] args){
            new HelloB();
        }
    }
    class HelloA
    {
        public HelloA(){
        }

        {
            System.out.println("I’m A class");
        }
  
        static{
            System.out.println("static A");
        }
    }

    //输出结果
    static A
    static B
    I’m A class
    I’m B class
    ````
    * 执行顺序：
        1. 父类静态代码块
        2. 子类静态代码块
        3. 父类普通代码块
        4. 父类构造方法
        5. 子类普通代码块
        6. 子类构造方法

    * 相同点
        * 都是在JVM加载类时且**在构造方法执行之前执行**，在类中都可以定义多个，一般在代码块中对一些static变量进行赋值。
    * 不同点
        * 静态代码块在非静态代码块之前执行(**静态代码块—>非静态代码块—>构造方法**)。**静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次**。非静态代码块可在普通方法中定义(不过作用不大)；而**静态**代码块不行。

***

#### 接口和抽象类有什么区别

* 实现：抽象类的子类使用 **extends** 来继承；接口必须使用 **implements** 来实现接口。
* 构造函数：抽象类可以有构造函数；**接口不能有**。
* main 方法：抽象类可以有 main 方法，并且我们能运行它；**接口不能有 main 方法**。
* 实现数量：**类可以实现很多个接口**；但是**只能继承一个抽象类**。
* 访问**修饰符**：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。

***

#### String a="i" 和String b=new String("i")的区别

* 前者，Java虚拟机将其分配到**常量池**中,并把"i"的内存地址赋给a,如果还有一个String a1="i",也把"i"的内存地址赋给a1，即**a和a1这两个引用的是同一个地址，共享一个内存。**
* 后者，则会被分配到**堆内存**中，即新创建了一个对象，如果还有一个String b1=new String("i")，相当于又创建了一个对象，然后将其地址赋给b1，**虽然b和b1值相同，但是并不是一个对象。**

***

#### String类的常用方法有哪些

* `indexof()`   ：放回指定字符索引
* `charAt()`    ：返回指定索引处字符
* `replace()`   ：字符串替换
* `trim()`      :去除字符串两端空白
* `spilt()`     ：分割字符串，返回一个分割后的字符串数组
* `getBytes()`  ：返回字符串的 byte 类型数组。ASCII码
* `length()`    ：返回字符串长度。
* `toLowerCase()`：将字符串转成小写字母。
* `toUpperCase()`：将字符串转成大写字符。
* substring()   ：截取字符串。
* equals()      ：字符串比较。

***

#### Files的常用方法

* `Files.exists()`      ：    检测文件路径是否存在。
* `Files.createFile()`  ：创建文件。
* `Files.createDirectory()`：创建文件夹。
* `Files.delete()`      ：删除一个文件或目录。
* `Files.copy()`        ：复制文件。
* `Files.move()`        ：移动文件。
* `Files.size()`        ：查看文件个数。
* `Files.read()`        ：读取文件。
* `Files.write()`       ：写入文件。

***

#### java创建对象的方法

1. 用new语句创建对象，是最常见的创建对象的方法。
2. 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
3. 调用对象的clone()方法。
4. 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。

***

#### assert

* 断言。是在软件开发过程中的一种调试方法。它对一个boolean表达式进行检验。一个正确的程序必须保证这个表达式正确，如果不正确系统则会给出警告或者退出。一般来说，**asset用于保证程序最基本，最关键代码的正确性**。软件发布后，通常assert检查通常是关闭的。
* 

***

####  抽象类

* 抽象类不一定要有抽象方法
* 抽象类不能使用final,因为被final标记的类不能被继承，但抽象类就是为了让其子类继承的
* 抽象类和普通类的区别
    * **抽象类不能实例化**，普通类可以    绝不会拿3e
    * **普通类不能含有抽象方法**，抽象类可以有抽象方法
***






&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;









































## 2. 容器

* 常用容器目录
    ![常用容器目录](https://img-blog.csdnimg.cn/20190317184953342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70)
***

* Collection和Collections的区别
    * Collection是集合类的上层接口，继承他的接口主要有Set和List
    * Collections是针对于集合类的一个帮助类，他提供了一系列的静态方法实现对集合的搜索、排序、线程安全化等操作。 
***

* map的分类和常见的情况 
    * java.util.Map接口主要用于存储键值对，根据键得到值，**因此不允许键重复，但允许值重复**，它有四个实现类：
        * Hashmap:根据键的hashCode值存储数据，具有很快的访问速度，**遍历时，具有很快的访问速度，但取得的速度是随机的。Hashmap不支持线程的同步**,多个线程同时读取会导致数据的不一致，**若需要同步，可以使用Collections的synchronizedMap()方法使Hashmap具有同步能力或者使用ConcurrentHashMap**.
            * ConcurrentHashMap分段锁
            * HashMap允许任何类型的键和值对象，并**允许将null用作键或值**
        * Hashtable与HashMap类似，不同的是**它不允许记录的键或值为空，它支持线程同步**， 即任何时候只有一个线程能写Hashtable但也因此**导致了hashtable访问较慢**。
        * LinkedHashMap是Hashmap的一个子类，**保存了记录的插入顺序，用iterator遍历时先得到的记录肯定是先插入的。遍历速度比HashMap慢**，除非HashMap容量很大但实际数据较少。
        * TreeMap实现的是SortMap接口，**能够把它保存的记录按照键排序**，用iterator遍历的数据是排过序的。
            * TreeMap的实现底层实现**基于二叉树的红黑树**，插入的值是按一定顺序排序的。
        >一般情况下，用的最多的是HashMap，用它插入，删除，定位是最好的选择。但如果按照自然顺序或按照自定义顺序，TreeMap更好，如果要输入输出顺序一样，LinkedHashMap更好。
***

* HashMap的实现原理
    * HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>
    HashMap的数据结构： **在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）**，所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“**链表散列**”的数据结构，即数组和链表的结合体。<br>
    当我们往Hashmap中put元素时,**首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。**<br>
    需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)
***

* HashSet
    * 实现原理
        * HashSet底层由HashMap实现，HashSet的值存放于HashMap的Key上，HashMap的**value统一为PRESENT**
    * 特性
        * 它存储**唯一**元素并**允许空值**
        * 它由HashMap支持
        * 它**不保持插入顺序**
        * 它**不是线程安全**的
    * API
        * add():可用于**将元素添加到一组**。方法声明只有当元素尚未存在于集合中时才会添加元素。如果成功添加了元素，则该方法返回true，否则返回false。
        * contains():目的是**检查给定HashSet中是否存在元素**。如果找到该元素，则返回true，否则返回false。
        * remove():如果存在，该方法将从集合中**删除指定的元素**。如果集合包含指定的元素，则此方法返回true。
        * clear():当我们打算从集合中**删除所有项目时**，我们使用此方法。底层实现只是清除底层HashMap中的所有元素。
        *  size():这是API中的基本方法之一。它被大量使用，因为它有助于识别HashSet中存在的元素数量。底层实现只是将计算委托给HashMap的size（）方法。
        *  isEmpty():我们可以使用此方法来确定**HashSet的给定实例是否为空**。如果集合不包含任何元素，则此方法返回true
        * Iterator():该方法返回Set中元素的**迭代器**。这些元素**没有特定的顺序**访问，Iterator是fail-fast的。
***


* 数组(Array)和列表(ArrayList)的区别
    * **Array可以包含基本类型或者对象类型，Arraylist只能包含对象类型；**
    * Array大小是固定对的，ArrayList不是。
    * 对于基本数据类型，Array使用自动装箱来减少编码工作量，但当处理固定大小的基本上数据类型时这种方式较慢。
***

* ArrayList、LinkedList和Vector
    * ArrayList和LinkedList最明显的区别是ArrayList的底层数据结构是**数组，支持随机访问，因此插入慢，读取快**。而LinkedList的底层数据结构是**双向循环链表，不支持随机访问,因此写入块，读取慢**，Array的时间复杂度是O(1),LinkedList是O(n);
      
        >随机访问只是读取时索引顺序每次有差别，但是可以保证遍历出来的结果顺序是一样的
    * Vector也是数组方式存储数据，和ArrayList一样数组元素数大于实际存储的数据，不同的是**Vector支持线程安全**，所以性能比ArrayList弱一些。
***

* 如何实现数组和List之间的转换 
    * List转为数组：调用Arrayl的**toArray()** 方法
    * 数组转为List：调用Arrays的**asList**方法    [cici](https://blog.csdn.net/qq_41097354/article/details/90403953?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)
***

* 迭代器Iterator
    * 什么是Iterator
        * 迭代器是一种设计模式，它是一个对象，它可以**遍历并选择序列中的对象**，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“**轻量级**”对象，因为创建它的代价小。
    * 如何使用？有何特点？
        * Java中的Iterator功能比较简单，并且只能**单向 
        * *lk--9移动**：
        * (1) 使用方法iterator()要求容器返回一个Iterator。**第一次调用Iterator的next()方法时，它返回序列的第一个元素**。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
        * (2) **使用next()获得序列中的下一个元素。**
        * (3) **使用hasNext()检查序列中是否还有元素。**
        * (4) 使用remove()将迭代器**新返回的元素删除**。　
    * Iterator和ListIterator的区别
        * Iterator可用来**遍历Set和List集合**，但是**ListIterator只能用来遍历List**
        * Iterator对集合只能是向前遍历，ListIterator**既可以前向也可以后向。**
    * ListIterator实现了Iterator接口，**并包含其他的功能**，比如：**增加元素**，**替换元素**，**获取前一个和后一个元素的索引**，等等。
    
    ````java
            ArrayList<Student> arrays= new ArrayList<>();
            arrays.add(new Student("wang",21));
            arrays.add(new Student("li",22));
            Iterator<Student> iterator=arrays.iterator();
            while(iterator.hasNext()){
                System.out.println(iterator.next());
            }
    ````

    
* Iterator和Enumeration 
    * Iterator除了能读取集合的数据之外，也能数据进行删除操作；而**Enumeration只能读取集合的数据，而不能对数据进行修改**。
    * Iterator是基于Enumeration实现的，同时Iterator支持fail-fast机制，所以**Iterator遍历集合时会比Enumeration遍历集合慢一些**。

***

* lambda 表达式 
    * 示例：
        ```java
        // 1. 不需要参数,返回值为 5  
        () -> 5  
        
        // 2. 接收一个参数(数字类型),返回其2倍的值  
        x -> 2 * x  
        
        // 3. 接受2个参数(数字),并返回他们的差值  
        (x, y) -> x – y  
        
        // 4. 接收2个int型整数,返回他们的和  
        (int x, int y) -> x + y  
        
        // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
        (String s) -> System.out.print(s)
        ```
***








&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;




















## 3. 线程

### 创建进程的方式
* 继承Thread类创建线程类
    1. **定义Thread类的子类**，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
    2. 创建Thread子类的实例，即创建了线程对象。
    3. 调用线程对象的start()方法来启动该线程。
* 通过Runnable接口创建线程类
    1. 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
    2. 创建 Runnable实现类的实例，并依此实例**作为Thread的target**来创建Thread对象，该Thread对象才是真正的线程对象。
    3. 调用线程对象的start()方法来启动该线程。
* 通过Callable和Future创建线程
    1. 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
    2. 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
    3. 使用FutureTask对象作为Thread对象的target创建并启动新线程。
    4. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。
***

### 线程的状态
* **创建状态**。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
* **就绪状态**。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
* **运行状态**。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
* **阻塞状态**。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
* **死亡状态**。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 
***

### 并行和并发的区别
* 并行是指两个或者多个事件在**同一时刻**发生；
* 并发是指两个或多个事件在**同一时间间隔**发生。
* 并行是在**不同实体**上的多个事件
* 并发是在**同一实体**上的多个事件
***

### synchronized
* 被它修饰的方法**使其只能每次被单一的线程存取**。
* ~~修饰方法、对象、代码块~~
***

### synchronized 和 volatile 的区别
* volatile本质是在**告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取**； synchronized则是**锁定当前变量**，只有当前线程可以访问该变量，其他线程被阻塞住。
* volatile仅能使用在**变量级别**；synchronized则可以使用在变量、方法、和类级别的。
* volatile仅能实现变量的修改可见性，**不能保证原子性**；而synchronized则可以保证变量的修改可见性和原子性。
* volatile**不会造成线程的阻塞**；synchronized可能会造成线程的阻塞。
* volatile**标记的变量不会被编译器优化**；synchronized标记的变量可以被编译器优化。
***

### synchronized 和 Lock 的区别
* 首先synchronized是**java内置关键字**，在jvm层面，**Lock是个java类**；
* **synchronized无法判断是否获取锁的状态**，**Lock可以判断是否获取到锁**；
* synchronized会**自动释放锁**(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中**手工释放锁**（unlock()方法释放锁），否则容易造成线程死锁；
* 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。**如果线程1阻塞，线程2则会一直等待下去**，而Lock锁就不一定会等待下去，如果**尝试获取不到锁，线程可以不用一直等待就结束了**；
* Lock锁**适合大量同步的代码**的同步问题，synchronized锁适合代码少量的同步问题。
* synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；
***

### 线程和进程
* **进程是资源分配**的最小单元，**线程是CPU调度**的最小单元
    
    >进程=火车 线程=车厢
* **线程在进程下进行**
* 一个进程可以包含多个线程
* 不同进程间数据很难共享
>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。**进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源**，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。
***

### 守护线程
* 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。
***

### runable和callable的区别
* Runnable接口中的**run()方法的返回值是void**，它做的事情只是**纯粹地去执行**run()方法中的代码而已；
* Callable接口中的**call()方法是有返回值的**，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。
***

### sleep和wait的区别
![sleep和wait](https://i.loli.net/2020/04/06/ekJtWQjuX1a6MgZ.png)
* sleep()：方法是**线程类（Thread）的静态方法**，让调用线程**进入睡眠状态，让出执行机会给其他线程**，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程**虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象**。
* wait()：**wait()是Object类的方法**，当一个线程执行到wait方法时，它就**进入**到一个和该对象相关的**等待池**，**同时释放对象的机锁**，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程
***

### 线程的 run()和 start()的区别
>每个线程都是通过某个特定target对象所对应的方法**run()来完成其操作**的，**方法run()称为线程体**。通过调用Thread类的start()方法来启动一个线程。
>**start()方法来启动一个线程，**真正实现了多线程运行。这时**无需等待run方法体代码执行完毕，可以直接继续执行下面的代码**； 这时此线程是**处于就绪状态， 并没有运行**。 然后通过此Thread类**调用方法run()来完成其运行状态**， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。
>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。
***

### 线程池
* <u><https://www.jianshu.com/p/7726c70cdc40></u>
***

### java程序中怎么保证多线程的运行安全
* 线程安全在三个方面体现：
    * 原子性：提供互斥访问，**同一时刻只能有一个线程对数据进行操作**
    * 可见性：**一个线程对主内存的修改可以及时地被其他线程看到**，一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序
    * 有序性：指程序在执行的时候，**程序的代码执行顺序和语句的顺序是一致的**
***

### 多线程锁的升级原理是什么
* 在Java中，锁共有4种状态，级别从低到高依次为：**无状态锁，偏向锁，轻量级锁和重量级锁**状态，这几个状态会随着竞争情况逐渐升级。锁**可以升级但不能降级**。
* 锁升级状态 [详解各种锁](http://ifeve.com/java-synchronized/)
![锁升级状态](https://img-blog.csdnimg.cn/20190317183206697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70)
***

### Java的锁
* [Java中的各种锁详细介绍](https://www.cnblogs.com/jyroy/p/11365935.html)
    ![Java锁](https://img-blog.csdnimg.cn/20181122101753671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70)
* 乐观锁 VS 悲观锁
* 自旋锁 VS 适应性自旋锁
* 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
* 公平锁 VS 非公平锁
* 可重入锁 VS 非可重入锁
* 独享锁 VS 共享锁#
***

### 什么是死锁
* 死锁是指两个或两个以上的进程在执行过程中，**由于竞争资源或者由于彼此通信而造成的一种阻塞的现象**，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是**操作系统层面的一个错误**，是进程死锁的简称，
* 死锁产生的四个必要条件：
    * 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
    * 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
    * 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
    *环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系

* 如何防止死锁
        * 参照产生的四个必要条件，只要不满足其一，就可防止死锁
***


### ThreadLocal 
* **线程局部变量**是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

* [详解ThreadLocal](https://www.jianshu.com/p/3c5d7f09dfbd)
***

 * **Servlet是线程不安全的**，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误
***

### 同步和异步
* 同步：如果数据在线程间共享，例如正在写的数据可能被另外一个线程读到，或者正在读的数据可能被另外一个线程写过了，那么这些数据就是共享数据，必须同步存取
* 异步：当应用程序在对象上调用了一个需要花很长时间来执行的方法，并且不希望让程序等待方法的返回是，就应该使用异步编程，往往异步编程更有效率。
***
### 并行和并发
* 并行是指多个事件在**同时刻**发生，并发是指多个事件在**同一时间间隔内**发生 
* 并行是在**不同实体上的多个事件**，并发是指在**同一实体上的多个事件**
    
* 并发编程的目的是充分利用处理器的每一个核，以达到最高的处理性能。
***


&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;





## 4. 反射

* 什么是反射
    * 反射主要是程序可以访问、检测和修改它本身状态或者行为的一种能力

* Java反射
    * Java反射机制主要提供以下功能
        * 在运行时**判断**任意一个对象**所属的类**。
        * 在运行时**构造任意一个类的对象**。
        * 在运行时**判断**任意一个类所**具有的成员变量和方法**。
        * 在运行时**调用任意一个对象的方法**。
***

* Java序列化
    * [serializable和serializaUID](https://baijiahao.baidu.com/s?id=1633305649182361563&wfr=spider&for=pc)
    * 简单说就是**为了保存在内存中的各种对象的状态（也就是实例变量**，不是方法），并且**可以把保存的对象状态再读出来**。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。序列化是**将对象状态转换为可保持或传输的格式的过程**。
    * 什么情况下需要序列化：
        * 当你想**把内存中的对象状态保存到一个文件中或者数据库中**时候；
        * 当你想**用套接字在网络上传送对象**的时候
        * 当你想**通过RMI传输对象**的时候

* 动态代理
    * 当想要**给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等**。可以给这个类创建一个代理，故名思议就是**创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类**。这个代理类**并不是定义好的，是动态生成**的。具有**解耦意义**，**灵活**，**扩展性强**。
    * 具体应用
        * Spring的AOP
        * 加事务
        * 加日志
        * 加权限
    * 如何实现
        * 首先必须**定义一个接口**，还有有一个**InvocationHandler(将实现接口的类的对象传递给它)处理类**，再有一个工具类**Proxy(代理类，调用它的newInstance()可以产生代理对象)**。
          
            >即利用到InvocationHandler,拼接代理类源码，将其编译成代理类的二级制码，利用类加载器加载，并向其实例化产生对象，最后返回。







&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;




## 5. 对象拷贝


* 为什么要使用克隆
    * 想对一个对象进行处理，但**需要保留原有的数据进行接下来的操作**，就需要克隆，Java语言中的克隆针对的是类的实例。
    * 如何实现
        * **实现Cloneable接口并重写Object类中的clone()方**法
        * **实现serializable接口**，**通过对象的序列化和反序列化**实现克隆，可以实现真正的深度克隆
        >而且基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。

    * 深浅克隆的区别
        * 浅克隆**只克隆他自身**以及**他包含的所有对象的引用地址**。
        * 深克隆**除自身以外所有的对象**，包括自身所包含的所有对象实例
            * 深克隆的实现
                * 重写Clone()时，调用引用类型的对象的clone()方法对其所包含对象重新赋值 **String是引用类型**
                * 使用serializable序列化

***








## 异常

### throw和throws
* throws是用来声明一个方法可能抛出的所有异常信息，throws是**将异常声明但是不处理，而是将异常往上传**，谁调用我就交给谁处理。而throw则是指**抛出的一个具体的异常类型**。
````java
    1.用户程序自定义的异常和应用程序特定的异常,必须借助于 throws 和 throw 语句来定义抛出异常。
        1.1   throw是语句抛出一个异常。
            语法：throw (异常对象);
        throw e;

        1.2   throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)
            语法：[(修饰符)](返回值类型)(方法名)([参数列表])[throws(异常类)]{......}
            public void doA(int a) throws Exception1,Exception3{......}
 ````
举例：
    throws E1,E2,E3只是告诉程序这个方法可能会抛出这些异常，方法的调用者可能要处理这些异常，而这些异常E1，E2，E3可能是该函数体产生的。
throw则是明确了这个地方要抛出这个异常。

    如： 
```java
    void doA(int a) throws IOException,{
            try{
                ......
    
            }catch(Exception1 e){
                throw e;
            }catch(Exception2 e){
                System.out.println("出错了！");
            }
            if(a!=b)
                throw new  Exception3("自定义异常");
    }
```

* throw
    1. throw语句用在方法体内，**表示抛出异常**，由方法体内的语句处理。
    2. throw是具体向外抛异常的动作，所以它是抛出一个异常实例。
    3. 而throw出现在函数体。
    4. throw的话，那就是你**把那个倾向变成真实的**了。
* throws
    1. throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。
    2. throws主要是**声明这个方法会抛出这种类型的异常**，使它的调用者知道要捕获这个异常。
    3.throws出现在方法函数头；
    4. throws说明你有那个**可能，倾向。**
* 两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。
***

### finally的作用
* finally里一般拿来**做一些善后清理工作**，try块里出现错误的话，会立即跳出try块，找到匹配的错误，执行catch块里的语句，此时，可能在try块里打开的文件没关闭，连接的网络没断开，对这些浪费的内存就不能及时释放回收。如果有finally块的话，不管有没有出错，都会执行finally块里的内容。
* finally**并不是必须存在的**,不过开发过程中建议加上finally,里面可以使用来执行打印日子代码,给出现问题时查看日子买下伏笔,做一些善后清理工作

* [finally执行顺序](https://blog.csdn.net/jdfk423/article/details/80406297)
* finally语句**在return语句执行之后return返回之前执行的**
* **finally有返回值时，会直接返回**。不会再去返回try或者catch中的返回值。
* 如果try和catch的return是一个变量时且函数的是从其中一个返回时，后面finally中语句即使有对返回的变量进行赋值的操作时，也**不会影响返回的值**。
***

* 常见的异常类
    * **NullPointerException**：当应用程序试图访问空对象时，则抛出该异常。
    * **SQLException**：提供关于数据库访问错误或其他错误信息的异常。
    * **IndexOutOfBoundsException**：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。
    * **NumberFormatException**：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
    * **FileNotFoundException**：当试图打开指定路径名表示的文件失败时，抛出此异常。
    * **IOException**：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。
    * **ClassCastException**：当试图将对象强制转换为不是实例的子类时，抛出该异常。
    * **ArrayStoreException**：试图将错误类型的对象存储到一个对象数组时抛出的异常。
    * **IllegalArgumentException**：抛出的异常表明向方法传递了一个不合法或不正确的参数。
    * **ArithmeticException**：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。
    * **NegativeArraySizeException**：如果应用程序试图创建大小为负的数组，则抛出该异常。
    * **SecurityException**：由安全管理器抛出的异常，指示存在安全侵犯。
    * **NoSuchMethodException**：无法找到某一特定方法时，抛出该异常。
    * **UnsupportedOperationException**：当不支持请求的操作时，抛出该异常。
    * **RuntimeExceptionRuntimeException**：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。
    * UnsupportedOperationException：使用Arrays.asList()生成的List是属于Arrays工具类中的内部静态类，不是java.util中的不能使用add()方法添加元素。























* 设计模式
    <https://blog.csdn.net/mq2553299/article/details/80962335>
    ![设计模式](https://i.loli.net/2020/04/07/iL9yoxwfhKA4GSk.png)
    * 工程模式
        * <https://www.cnblogs.com/enjoy-coding/p/4803543.html>
        * 提供一个创建一系列或相互依赖对象的接口，而不需指定它们具体的类。
        * 通俗的讲就是定义了多个产品的类，且只有一个工厂类，而这个工厂类根据需求的不同，可以产生不同产品类的对象。














### 3. WEB问题

* Get和Post的区别
    * **GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同**
        * GET在浏览器回退时是无害的，而POST会再次提交请求。
        * GET产生的URL地址可以被Bookmark，而POST不可以。
        * GET请求会被浏览器主动cache，而POST不会，除非手动设置。
        * GET请求只能进行url编码，而POST支持多种编码方式。
        * GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
        * GET请求在URL中传送的参数是有长度限制的，而POST么有。
        * 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
        * GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
        * GET参数通过URL传递，POST放在Request body中。
    
    * 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
    * 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
***



* * 
***


* Spring与Spring Boot
    * Springboot是springMVC的升级版，两者没有必然联系。Spring Boot是伴随着Spring4.0诞生的。
    * Spring Boot特点
        * 化繁为简，**简化配置**。
        * 备受关注，是下一代框架。
        * **微服务的入门级框架**。微服务是当下比较流行的架构，spring为微服务提供了一整套组件，称为SpringCloud，springcloud是建立在Spring Boot的基础之上的。
        * 使**编码**变得简单，使**配置**变得简单，使**部署**变得简单，使**监控**变得简单。
***

* 线程池
    *<https://blog.csdn.net/qq_31821675/article/details/105189304>

* 继承映射
    * **每个继承结构一张表**（table per class hierarchy），**不管多少个子类都用一张表**。 
    * **每个子类一张表**（table per subclass），**公共信息放一张表，特有信息放单独的表**。
    * **每个具体类一张表**（table per concrete class），**有多少个子类就有多少张表**。 
    >第一种方式属于单表策略，其优点在于查询子类对象的时候**无需表连接，查询速度快，适合多态查询**；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行**连接查询，不适合多态查询**。
***
* 什么是DAO模式
    * dao全称是data access object，数据库访问对象，主要的功能就是用于**进行数据操作**的，在程序的标准开发架构中属于**数据层的操作企业分层架构**
    * 功能：资源层主要是数据库的操作层，里面可以进行各种的数据存储，但是这些数据存储操作的时候肯定依靠SQL语句，之前也发现了，如果在一个程序中出现了过多的SQL语句直接操作，则jsp页面变得相当复杂，而且也不**便于程序的可重用性**。可以通过一个专门的数据库的操作组件完成，那么这个就是数据层的功能。
    * DAO层组成
        * DatabaseConnection：专门负责数据库的打开与关闭操作的类
        * VO：主要由属性、setter、getter方法组成，VO类中的属性与表中的字段相对应，每一个VO类的对象都表示表中的每一条记录；
        * DAO：主要定义操作的接口，定义一系列数据库的原子性操作，例如：增加、修改、删除、按ID查询等；
        * Impl ： DAO接口的真实实现类，完成具体的数据库操作，但是不负责数据库的打开和关闭；
        * Proxy ：代理实现类，主要完成数据库的打开和关闭，并且调用真实实现类对象的操作；
        * Factory ：工厂类，通过工厂类取得一个DAO的实例化对象。

