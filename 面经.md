## 面向对象编程
### [三大特征](https://www.cnblogs.com/fenjyang/p/11462278.html)
* 封装: 就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。
* 继承: 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
* 多态: ​ 多态是同一个行为具有多个不同表现形式或形态的能力。

### [面向对象设计六大原则](https://www.cnblogs.com/yeya/p/10655760.html)
* 单一职责原则:
    其定义是应该有且仅有一个类引起类的变更，这话的意思就是**一个类只担负一个职责**。 
* 开闭原则:
    一个软件实体如类、模块和函数应该**对扩展开放，对修改关闭**
* 里氏替换原则:
    **只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何异常。** 但是反过来就不行了，因为子类可以扩展父类没有的功能，同时子类还不能改变父类原有的功能。
* 依赖倒置原则:
    高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
* 接口隔离原则
    客户端不应该依赖它不需要的接口。**意思就是客户端需要什么接口就提供什么接口，把不需要的接口剔除掉**，这就需要对接口进行细化，保证接口的纯洁性。换成另一种说法就是，类间的依赖关系应该建立在最小的接口上，也就是建立单一的接口。
* 迪米特原则
    一个对象应该对其他对象有最少的了解。也就是说，**一个类应该对自己需要耦合或调用的类知道的最少**，类与类之间的关系越密切，耦合度越大，那么类的变化对其耦合的类的影响也会越大，这也是我们面向设计的核心原则：**低耦合，高内聚**。

## Java基础
### HashMap
* 初始容量：16
* 负载因子：0.75
* capacity：2的N次幂，tab=[(n - 1) & hash]
* 如果链表长度大于阈值（默认为8）时并且数组的长度小于64时，链表不会转换为红黑树，而是将数组进行扩容。这样做的目的考虑到数组的长度较小，尽量避开红黑树，这种情况下，转为红黑树，反而会降低效率问题，因为红黑树需要左旋，右旋，变色操作来保持平衡，所以当数组长度小于64，搜索时间会相对快些，考虑到性能和减少搜索的时间，只有当链表长度大于阈值（默认为8）时并且数组的长度大于64时，链表将会转换为红黑树。
* 扩容后如果树节点小于6，还原为链表

### [ConcurrentHashMap](https://www.jianshu.com/p/d0b37b927c48)
* 分段锁
>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。


## 多线程
### 自旋锁
* 耗用cpu资源，不消化系统资源： 单cpu没啥用，次数少，自选耗时短，多cpu适用


## JVM
* JVM内存模型
* 新生代，老年代
* 常见的垃圾回收器
    * 新生代串行
    * 老年代串行
    * 新生代并行
    * 老年代并行

